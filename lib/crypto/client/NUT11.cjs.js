"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const o=require("@noble/curves/abstract/utils"),u=require("@noble/hashes/sha256"),i=require("@noble/curves/secp256k1"),f=require("@noble/hashes/utils"),l=require("../common/NUT11.cjs.js"),S=e=>{const t=["P2PK",{nonce:o.bytesToHex(f.randomBytes(32)),data:e}],s=JSON.stringify(t);return new TextEncoder().encode(s)},a=(e,t)=>{const s=u.sha256(new TextDecoder().decode(e));return i.schnorr.sign(s,t)},d=(e,t)=>{const s=u.sha256(e);return i.schnorr.sign(s,t)},p=(e,t)=>{let s=[],n="";if(t instanceof Array)for(const r of t)s.push({priv:r,pub:o.bytesToHex(i.schnorr.getPublicKey(r))});else n=t;return e.map(r=>{try{const c=l.parseSecret(r.secret);if(c[0]!=="P2PK")throw new Error("unknown secret type");if(s.length){const g=s.find(y=>c[1].data===y.pub)?.priv;if(g)n=g;else throw new Error("no matching key found")}return h(r,o.hexToBytes(n))}catch{return r}})},P=(e,t)=>{const s=e.B_.toHex(!0),n=d(s,t);return e.witness={signatures:[o.bytesToHex(n)]},e},w=(e,t)=>e.map(s=>P(s,t)),h=(e,t)=>(e.witness||(e.witness={signatures:[o.bytesToHex(a(e.secret,t))]}),e);exports.createP2PKsecret=S;exports.getSignedOutput=P;exports.getSignedOutputs=w;exports.getSignedProof=h;exports.getSignedProofs=p;exports.signBlindedMessage=d;exports.signP2PKsecret=a;
//# sourceMappingURL=NUT11.cjs.js.map
