{"version":3,"file":"mint.cjs.js","sources":["../../src/crypto/mint/index.ts"],"sourcesContent":["import { ProjPointType } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { bytesToNumber } from '../util/utils.js';\nimport { BlindSignature, IntRange, Keyset, MintKeys, Proof } from '../common/index.js';\nimport { createRandomPrivateKey, deriveKeysetId, hashToCurve } from '../common/index.js';\nimport { HDKey } from '@scure/bip32';\n\nconst DERIVATION_PATH = \"m/0'/0'/0'\";\n\nexport type KeysetPair = {\n\tkeysetId: string;\n\tpubKeys: MintKeys;\n\tprivKeys: MintKeys;\n};\n\nexport type KeysetWithKeys = Keyset & {\n\tpubKeys: MintKeys;\n};\n\nexport function createBlindSignature(\n\tB_: ProjPointType<bigint>,\n\tprivateKey: Uint8Array,\n\tamount: number,\n\tid: string\n): BlindSignature {\n\tconst C_: ProjPointType<bigint> = B_.multiply(bytesToNumber(privateKey));\n\treturn { C_, amount, id };\n}\n\nexport function getPubKeyFromPrivKey(privKey: Uint8Array) {\n\treturn secp256k1.getPublicKey(privKey, true);\n}\n\nexport function createNewMintKeys(pow2height: IntRange<0, 65>, seed?: Uint8Array): KeysetPair {\n\tlet counter = 0n;\n\tconst pubKeys: MintKeys = {};\n\tconst privKeys: MintKeys = {};\n\tlet masterKey;\n\tif (seed) {\n\t\tmasterKey = HDKey.fromMasterSeed(seed);\n\t}\n\twhile (counter < pow2height) {\n\t\tconst index: string = (2n ** counter).toString();\n\t\tif (masterKey) {\n\t\t\tconst k = masterKey.derive(`${DERIVATION_PATH}/${counter}`).privateKey;\n\t\t\tif (k) {\n\t\t\t\tprivKeys[index] = k;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Could not derive Private key from: ${DERIVATION_PATH}/${counter}`);\n\t\t\t}\n\t\t} else {\n\t\t\tprivKeys[index] = createRandomPrivateKey();\n\t\t}\n\n\t\tpubKeys[index] = getPubKeyFromPrivKey(privKeys[index]);\n\t\tcounter++;\n\t}\n\tconst keysetId = deriveKeysetId(pubKeys);\n\treturn { pubKeys, privKeys, keysetId };\n}\n\nexport function verifyProof(proof: Proof, privKey: Uint8Array): boolean {\n\tconst Y: ProjPointType<bigint> = hashToCurve(proof.secret);\n\tconst aY: ProjPointType<bigint> = Y.multiply(bytesToNumber(privKey));\n\treturn aY.equals(proof.C);\n}\n"],"names":["DERIVATION_PATH","createBlindSignature","B_","privateKey","amount","id","bytesToNumber","getPubKeyFromPrivKey","privKey","secp256k1","createNewMintKeys","pow2height","seed","counter","pubKeys","privKeys","masterKey","HDKey","index","k","createRandomPrivateKey","keysetId","deriveKeysetId","verifyProof","proof","hashToCurve"],"mappings":"6MAOMA,EAAkB,aAYjB,SAASC,EACfC,EACAC,EACAC,EACAC,EACiB,CAEV,MAAA,CAAE,GADyBH,EAAG,SAASI,EAAA,cAAcH,CAAU,CAAC,EAC1D,OAAAC,EAAQ,GAAAC,CAAG,CACzB,CAEO,SAASE,EAAqBC,EAAqB,CAClD,OAAAC,YAAU,aAAaD,EAAS,EAAI,CAC5C,CAEgB,SAAAE,EAAkBC,EAA6BC,EAA+B,CAC7F,IAAIC,EAAU,GACd,MAAMC,EAAoB,CAAC,EACrBC,EAAqB,CAAC,EACxB,IAAAC,EAIJ,IAHIJ,IACSI,EAAAC,EAAAA,MAAM,eAAeL,CAAI,GAE/BC,EAAUF,GAAY,CACtB,MAAAO,GAAiB,IAAML,GAAS,SAAS,EAC/C,GAAIG,EAAW,CACR,MAAAG,EAAIH,EAAU,OAAO,GAAGhB,CAAe,IAAIa,CAAO,EAAE,EAAE,WAC5D,GAAIM,EACHJ,EAASG,CAAK,EAAIC,MAElB,OAAM,IAAI,MAAM,sCAAsCnB,CAAe,IAAIa,CAAO,EAAE,CACnF,MAESE,EAAAG,CAAK,EAAIE,yBAAuB,EAG1CN,EAAQI,CAAK,EAAIX,EAAqBQ,EAASG,CAAK,CAAC,EACrDL,GAAA,CAEK,MAAAQ,EAAWC,iBAAeR,CAAO,EAChC,MAAA,CAAE,QAAAA,EAAS,SAAAC,EAAU,SAAAM,CAAS,CACtC,CAEgB,SAAAE,EAAYC,EAAchB,EAA8B,CAGhE,OAF0BiB,EAAAA,YAAYD,EAAM,MAAM,EACrB,SAASlB,EAAA,cAAcE,CAAO,CAAC,EACzD,OAAOgB,EAAM,CAAC,CACzB"}