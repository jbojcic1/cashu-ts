{"version":3,"file":"common.cjs.js","sources":["../../src/crypto/common/index.ts"],"sourcesContent":["import { ProjPointType } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { bytesToNumber, encodeBase64toUint8, hexToNumber } from '../util/utils.js';\nimport { Buffer } from 'buffer';\n\nexport type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N\n\t? Acc[number]\n\t: Enumerate<N, [...Acc, Acc['length']]>;\n\nexport type IntRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>>;\n\nexport type MintKeys = { [k: string]: Uint8Array };\n\nexport type SerializedMintKeys = {\n\t[k: string]: string;\n};\n\nexport type Keyset = {\n\tid: string;\n\tunit: string;\n\tactive: boolean;\n};\n\nexport type BlindSignature = {\n\tC_: ProjPointType<bigint>;\n\tamount: number;\n\tid: string;\n};\n\nexport type SerializedBlindSignature = {\n\tC_: string;\n\tamount: number;\n\tid: string;\n};\n\nexport type DLEQ = {\n\ts: Uint8Array; // signature\n\te: Uint8Array; // challenge\n\tr?: bigint; // optional: blinding factor\n};\n\nexport type Proof = {\n\tC: ProjPointType<bigint>;\n\tsecret: Uint8Array;\n\tamount: number;\n\tid: string;\n\twitness?: Witness;\n};\n\nexport type SerializedProof = {\n\tC: string;\n\tsecret: string;\n\tamount: number;\n\tid: string;\n\twitness?: string;\n};\n\nexport type SerializedBlindedMessage = {\n\tB_: string;\n\tamount: number;\n\twitness?: string;\n};\n\nexport type Secret = [WellKnownSecret, SecretData];\n\nexport type WellKnownSecret = 'P2PK';\n\nexport type SecretData = {\n\tnonce: string;\n\tdata: string;\n\ttags?: Array<Array<string>>;\n};\n\nexport type Witness = {\n\tsignatures: Array<string>;\n};\n\nexport type Tags = {\n\t[k: string]: string;\n};\n\nexport type SigFlag = 'SIG_INPUTS' | 'SIG_ALL';\n\nconst DOMAIN_SEPARATOR = hexToBytes('536563703235366b315f48617368546f43757276655f43617368755f');\n\nexport function hashToCurve(secret: Uint8Array): ProjPointType<bigint> {\n\tconst msgToHash = sha256(Buffer.concat([DOMAIN_SEPARATOR, secret]));\n\tconst counter = new Uint32Array(1);\n\tconst maxIterations = 2 ** 16;\n\tfor (let i = 0; i < maxIterations; i++) {\n\t\tconst counterBytes = new Uint8Array(counter.buffer);\n\t\tconst hash = sha256(Buffer.concat([msgToHash, counterBytes]));\n\t\ttry {\n\t\t\treturn pointFromHex(bytesToHex(Buffer.concat([new Uint8Array([0x02]), hash])));\n\t\t} catch (error) {\n\t\t\tcounter[0]++;\n\t\t}\n\t}\n\tthrow new Error('No valid point found');\n}\n\nexport function hash_e(pubkeys: Array<ProjPointType<bigint>>): Uint8Array {\n\tconst hexStrings = pubkeys.map((p) => p.toHex(false));\n\tconst e_ = hexStrings.join('');\n\tconst e = sha256(new TextEncoder().encode(e_));\n\treturn e;\n}\n\nexport function pointFromBytes(bytes: Uint8Array) {\n\treturn secp256k1.ProjectivePoint.fromHex(bytesToHex(bytes));\n}\n\nexport function pointFromHex(hex: string) {\n\treturn secp256k1.ProjectivePoint.fromHex(hex);\n}\n\nexport const getKeysetIdInt = (keysetId: string): bigint => {\n\tlet keysetIdInt: bigint;\n\tif (/^[a-fA-F0-9]+$/.test(keysetId)) {\n\t\tkeysetIdInt = hexToNumber(keysetId) % BigInt(2 ** 31 - 1);\n\t} else {\n\t\t//legacy keyset compatibility\n\t\tkeysetIdInt = bytesToNumber(encodeBase64toUint8(keysetId)) % BigInt(2 ** 31 - 1);\n\t}\n\treturn keysetIdInt;\n};\n\nexport function createRandomPrivateKey() {\n\treturn secp256k1.utils.randomPrivateKey();\n}\n\nexport function serializeMintKeys(mintKeys: MintKeys): SerializedMintKeys {\n\tconst serializedMintKeys: SerializedMintKeys = {};\n\tObject.keys(mintKeys).forEach((p) => {\n\t\tserializedMintKeys[p] = bytesToHex(mintKeys[p]);\n\t});\n\treturn serializedMintKeys;\n}\n\nexport function deserializeMintKeys(serializedMintKeys: SerializedMintKeys): MintKeys {\n\tconst mintKeys: MintKeys = {};\n\tObject.keys(serializedMintKeys).forEach((p) => {\n\t\tmintKeys[p] = hexToBytes(serializedMintKeys[p]);\n\t});\n\treturn mintKeys;\n}\n\nexport function deriveKeysetId(keys: MintKeys): string {\n\tconst KEYSET_VERSION = '00';\n\tconst mapBigInt = (k: [string, string]): [bigint, string] => {\n\t\treturn [BigInt(k[0]), k[1]];\n\t};\n\tconst pubkeysConcat = Object.entries(serializeMintKeys(keys))\n\t\t.map(mapBigInt)\n\t\t.sort((a, b) => (a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0))\n\t\t.map(([, pubKey]) => hexToBytes(pubKey))\n\t\t.reduce((prev, curr) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\tconst hash = sha256(pubkeysConcat);\n\tconst hashHex = Buffer.from(hash).toString('hex').slice(0, 14);\n\treturn '00' + hashHex;\n}\n\nfunction mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n"],"names":["DOMAIN_SEPARATOR","hexToBytes","hashToCurve","secret","msgToHash","sha256","Buffer","counter","maxIterations","counterBytes","hash","pointFromHex","bytesToHex","hash_e","pubkeys","e_","p","pointFromBytes","bytes","secp256k1","hex","getKeysetIdInt","keysetId","keysetIdInt","hexToNumber","bytesToNumber","encodeBase64toUint8","createRandomPrivateKey","serializeMintKeys","mintKeys","serializedMintKeys","deserializeMintKeys","deriveKeysetId","keys","mapBigInt","k","pubkeysConcat","a","b","pubKey","prev","curr","mergeUInt8Arrays","a1","a2","mergedArray"],"mappings":"sPAqFMA,EAAmBC,aAAW,0DAA0D,EAEvF,SAASC,EAAYC,EAA2C,CAChE,MAAAC,EAAYC,EAAAA,OAAOC,EAAO,OAAA,OAAO,CAACN,EAAkBG,CAAM,CAAC,CAAC,EAC5DI,EAAU,IAAI,YAAY,CAAC,EAC3BC,EAAgB,GAAK,GAC3B,QAAS,EAAI,EAAG,EAAIA,EAAe,IAAK,CACvC,MAAMC,EAAe,IAAI,WAAWF,EAAQ,MAAM,EAC5CG,EAAOL,EAAAA,OAAOC,EAAO,OAAA,OAAO,CAACF,EAAWK,CAAY,CAAC,CAAC,EACxD,GAAA,CACH,OAAOE,EAAaC,EAAAA,WAAWN,EAAO,OAAA,OAAO,CAAC,IAAI,WAAW,CAAC,CAAI,CAAC,EAAGI,CAAI,CAAC,CAAC,CAAC,OAC9D,CACfH,EAAQ,CAAC,GAAA,CACV,CAEK,MAAA,IAAI,MAAM,sBAAsB,CACvC,CAEO,SAASM,EAAOC,EAAmD,CAEnE,MAAAC,EADaD,EAAQ,IAAKE,GAAMA,EAAE,MAAM,EAAK,CAAC,EAC9B,KAAK,EAAE,EAEtB,OADGX,EAAAA,OAAO,IAAI,cAAc,OAAOU,CAAE,CAAC,CAE9C,CAEO,SAASE,EAAeC,EAAmB,CACjD,OAAOC,EAAU,UAAA,gBAAgB,QAAQP,EAAA,WAAWM,CAAK,CAAC,CAC3D,CAEO,SAASP,EAAaS,EAAa,CAClC,OAAAD,YAAU,gBAAgB,QAAQC,CAAG,CAC7C,CAEa,MAAAC,EAAkBC,GAA6B,CACvD,IAAAC,EACA,MAAA,iBAAiB,KAAKD,CAAQ,EACjCC,EAAcC,cAAYF,CAAQ,EAAI,OAAO,GAAK,GAAK,CAAC,EAG1CC,EAAAE,EAAAA,cAAcC,EAAAA,oBAAoBJ,CAAQ,CAAC,EAAI,OAAO,GAAK,GAAK,CAAC,EAEzEC,CACR,EAEO,SAASI,GAAyB,CACjC,OAAAR,EAAA,UAAU,MAAM,iBAAiB,CACzC,CAEO,SAASS,EAAkBC,EAAwC,CACzE,MAAMC,EAAyC,CAAC,EAChD,cAAO,KAAKD,CAAQ,EAAE,QAASb,GAAM,CACpCc,EAAmBd,CAAC,EAAIJ,EAAW,WAAAiB,EAASb,CAAC,CAAC,CAAA,CAC9C,EACMc,CACR,CAEO,SAASC,EAAoBD,EAAkD,CACrF,MAAMD,EAAqB,CAAC,EAC5B,cAAO,KAAKC,CAAkB,EAAE,QAASd,GAAM,CAC9Ca,EAASb,CAAC,EAAIf,EAAW,WAAA6B,EAAmBd,CAAC,CAAC,CAAA,CAC9C,EACMa,CACR,CAEO,SAASG,EAAeC,EAAwB,CAEhD,MAAAC,EAAaC,GACX,CAAC,OAAOA,EAAE,CAAC,CAAC,EAAGA,EAAE,CAAC,CAAC,EAErBC,EAAgB,OAAO,QAAQR,EAAkBK,CAAI,CAAC,EAC1D,IAAIC,CAAS,EACb,KAAK,CAACG,EAAGC,IAAOD,EAAE,CAAC,EAAIC,EAAE,CAAC,EAAI,GAAKD,EAAE,CAAC,EAAIC,EAAE,CAAC,EAAI,EAAI,CAAE,EACvD,IAAI,CAAC,CAAA,CAAGC,CAAM,IAAMtC,aAAWsC,CAAM,CAAC,EACtC,OAAO,CAACC,EAAMC,IAASC,EAAiBF,EAAMC,CAAI,EAAG,IAAI,UAAY,EACjE/B,EAAOL,SAAO+B,CAAa,EAEjC,MAAO,KADS9B,EAAAA,OAAO,KAAKI,CAAI,EAAE,SAAS,KAAK,EAAE,MAAM,EAAG,EAAE,CAE9D,CAEA,SAASgC,EAAiBC,EAAgBC,EAA4B,CAErE,MAAMC,EAAc,IAAI,WAAWF,EAAG,OAASC,EAAG,MAAM,EACxD,OAAAC,EAAY,IAAIF,CAAE,EACNE,EAAA,IAAID,EAAID,EAAG,MAAM,EACtBE,CACR"}