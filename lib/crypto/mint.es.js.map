{"version":3,"file":"mint.es.js","sources":["../../src/crypto/mint/index.ts"],"sourcesContent":["import { ProjPointType } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { bytesToNumber } from '../util/utils.js';\nimport { BlindSignature, IntRange, Keyset, MintKeys, Proof } from '../common/index.js';\nimport { createRandomPrivateKey, deriveKeysetId, hashToCurve } from '../common/index.js';\nimport { HDKey } from '@scure/bip32';\n\nconst DERIVATION_PATH = \"m/0'/0'/0'\";\n\nexport type KeysetPair = {\n\tkeysetId: string;\n\tpubKeys: MintKeys;\n\tprivKeys: MintKeys;\n};\n\nexport type KeysetWithKeys = Keyset & {\n\tpubKeys: MintKeys;\n};\n\nexport function createBlindSignature(\n\tB_: ProjPointType<bigint>,\n\tprivateKey: Uint8Array,\n\tamount: number,\n\tid: string\n): BlindSignature {\n\tconst C_: ProjPointType<bigint> = B_.multiply(bytesToNumber(privateKey));\n\treturn { C_, amount, id };\n}\n\nexport function getPubKeyFromPrivKey(privKey: Uint8Array) {\n\treturn secp256k1.getPublicKey(privKey, true);\n}\n\nexport function createNewMintKeys(pow2height: IntRange<0, 65>, seed?: Uint8Array): KeysetPair {\n\tlet counter = 0n;\n\tconst pubKeys: MintKeys = {};\n\tconst privKeys: MintKeys = {};\n\tlet masterKey;\n\tif (seed) {\n\t\tmasterKey = HDKey.fromMasterSeed(seed);\n\t}\n\twhile (counter < pow2height) {\n\t\tconst index: string = (2n ** counter).toString();\n\t\tif (masterKey) {\n\t\t\tconst k = masterKey.derive(`${DERIVATION_PATH}/${counter}`).privateKey;\n\t\t\tif (k) {\n\t\t\t\tprivKeys[index] = k;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Could not derive Private key from: ${DERIVATION_PATH}/${counter}`);\n\t\t\t}\n\t\t} else {\n\t\t\tprivKeys[index] = createRandomPrivateKey();\n\t\t}\n\n\t\tpubKeys[index] = getPubKeyFromPrivKey(privKeys[index]);\n\t\tcounter++;\n\t}\n\tconst keysetId = deriveKeysetId(pubKeys);\n\treturn { pubKeys, privKeys, keysetId };\n}\n\nexport function verifyProof(proof: Proof, privKey: Uint8Array): boolean {\n\tconst Y: ProjPointType<bigint> = hashToCurve(proof.secret);\n\tconst aY: ProjPointType<bigint> = Y.multiply(bytesToNumber(privKey));\n\treturn aY.equals(proof.C);\n}\n"],"names":["DERIVATION_PATH","createBlindSignature","B_","privateKey","amount","id","bytesToNumber","getPubKeyFromPrivKey","privKey","secp256k1","createNewMintKeys","pow2height","seed","counter","pubKeys","privKeys","masterKey","HDKey","index","k","createRandomPrivateKey","keysetId","deriveKeysetId","verifyProof","proof","hashToCurve"],"mappings":";;;;AAOA,MAAMA,IAAkB;AAYjB,SAASC,EACfC,GACAC,GACAC,GACAC,GACiB;AAEV,SAAA,EAAE,IADyBH,EAAG,SAASI,EAAcH,CAAU,CAAC,GAC1D,QAAAC,GAAQ,IAAAC,EAAG;AACzB;AAEO,SAASE,EAAqBC,GAAqB;AAClD,SAAAC,EAAU,aAAaD,GAAS,EAAI;AAC5C;AAEgB,SAAAE,EAAkBC,GAA6BC,GAA+B;AAC7F,MAAIC,IAAU;AACd,QAAMC,IAAoB,CAAC,GACrBC,IAAqB,CAAC;AACxB,MAAAC;AAIJ,OAHIJ,MACSI,IAAAC,EAAM,eAAeL,CAAI,IAE/BC,IAAUF,KAAY;AACtB,UAAAO,KAAiB,MAAML,GAAS,SAAS;AAC/C,QAAIG,GAAW;AACR,YAAAG,IAAIH,EAAU,OAAO,GAAGhB,CAAe,IAAIa,CAAO,EAAE,EAAE;AAC5D,UAAIM;AACH,QAAAJ,EAASG,CAAK,IAAIC;AAAA;AAElB,cAAM,IAAI,MAAM,sCAAsCnB,CAAe,IAAIa,CAAO,EAAE;AAAA,IACnF;AAES,MAAAE,EAAAG,CAAK,IAAIE,EAAuB;AAG1C,IAAAN,EAAQI,CAAK,IAAIX,EAAqBQ,EAASG,CAAK,CAAC,GACrDL;AAAA,EAAA;AAEK,QAAAQ,IAAWC,EAAeR,CAAO;AAChC,SAAA,EAAE,SAAAA,GAAS,UAAAC,GAAU,UAAAM,EAAS;AACtC;AAEgB,SAAAE,EAAYC,GAAchB,GAA8B;AAGhE,SAF0BiB,EAAYD,EAAM,MAAM,EACrB,SAASlB,EAAcE,CAAO,CAAC,EACzD,OAAOgB,EAAM,CAAC;AACzB;"}