{"version":3,"file":"common.es.js","sources":["../../src/crypto/common/index.ts"],"sourcesContent":["import { ProjPointType } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { bytesToNumber, encodeBase64toUint8, hexToNumber } from '../util/utils.js';\nimport { Buffer } from 'buffer';\n\nexport type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N\n\t? Acc[number]\n\t: Enumerate<N, [...Acc, Acc['length']]>;\n\nexport type IntRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>>;\n\nexport type MintKeys = { [k: string]: Uint8Array };\n\nexport type SerializedMintKeys = {\n\t[k: string]: string;\n};\n\nexport type Keyset = {\n\tid: string;\n\tunit: string;\n\tactive: boolean;\n};\n\nexport type BlindSignature = {\n\tC_: ProjPointType<bigint>;\n\tamount: number;\n\tid: string;\n};\n\nexport type SerializedBlindSignature = {\n\tC_: string;\n\tamount: number;\n\tid: string;\n};\n\nexport type DLEQ = {\n\ts: Uint8Array; // signature\n\te: Uint8Array; // challenge\n\tr?: bigint; // optional: blinding factor\n};\n\nexport type Proof = {\n\tC: ProjPointType<bigint>;\n\tsecret: Uint8Array;\n\tamount: number;\n\tid: string;\n\twitness?: Witness;\n};\n\nexport type SerializedProof = {\n\tC: string;\n\tsecret: string;\n\tamount: number;\n\tid: string;\n\twitness?: string;\n};\n\nexport type SerializedBlindedMessage = {\n\tB_: string;\n\tamount: number;\n\twitness?: string;\n};\n\nexport type Secret = [WellKnownSecret, SecretData];\n\nexport type WellKnownSecret = 'P2PK';\n\nexport type SecretData = {\n\tnonce: string;\n\tdata: string;\n\ttags?: Array<Array<string>>;\n};\n\nexport type Witness = {\n\tsignatures: Array<string>;\n};\n\nexport type Tags = {\n\t[k: string]: string;\n};\n\nexport type SigFlag = 'SIG_INPUTS' | 'SIG_ALL';\n\nconst DOMAIN_SEPARATOR = hexToBytes('536563703235366b315f48617368546f43757276655f43617368755f');\n\nexport function hashToCurve(secret: Uint8Array): ProjPointType<bigint> {\n\tconst msgToHash = sha256(Buffer.concat([DOMAIN_SEPARATOR, secret]));\n\tconst counter = new Uint32Array(1);\n\tconst maxIterations = 2 ** 16;\n\tfor (let i = 0; i < maxIterations; i++) {\n\t\tconst counterBytes = new Uint8Array(counter.buffer);\n\t\tconst hash = sha256(Buffer.concat([msgToHash, counterBytes]));\n\t\ttry {\n\t\t\treturn pointFromHex(bytesToHex(Buffer.concat([new Uint8Array([0x02]), hash])));\n\t\t} catch (error) {\n\t\t\tcounter[0]++;\n\t\t}\n\t}\n\tthrow new Error('No valid point found');\n}\n\nexport function hash_e(pubkeys: Array<ProjPointType<bigint>>): Uint8Array {\n\tconst hexStrings = pubkeys.map((p) => p.toHex(false));\n\tconst e_ = hexStrings.join('');\n\tconst e = sha256(new TextEncoder().encode(e_));\n\treturn e;\n}\n\nexport function pointFromBytes(bytes: Uint8Array) {\n\treturn secp256k1.ProjectivePoint.fromHex(bytesToHex(bytes));\n}\n\nexport function pointFromHex(hex: string) {\n\treturn secp256k1.ProjectivePoint.fromHex(hex);\n}\n\nexport const getKeysetIdInt = (keysetId: string): bigint => {\n\tlet keysetIdInt: bigint;\n\tif (/^[a-fA-F0-9]+$/.test(keysetId)) {\n\t\tkeysetIdInt = hexToNumber(keysetId) % BigInt(2 ** 31 - 1);\n\t} else {\n\t\t//legacy keyset compatibility\n\t\tkeysetIdInt = bytesToNumber(encodeBase64toUint8(keysetId)) % BigInt(2 ** 31 - 1);\n\t}\n\treturn keysetIdInt;\n};\n\nexport function createRandomPrivateKey() {\n\treturn secp256k1.utils.randomPrivateKey();\n}\n\nexport function serializeMintKeys(mintKeys: MintKeys): SerializedMintKeys {\n\tconst serializedMintKeys: SerializedMintKeys = {};\n\tObject.keys(mintKeys).forEach((p) => {\n\t\tserializedMintKeys[p] = bytesToHex(mintKeys[p]);\n\t});\n\treturn serializedMintKeys;\n}\n\nexport function deserializeMintKeys(serializedMintKeys: SerializedMintKeys): MintKeys {\n\tconst mintKeys: MintKeys = {};\n\tObject.keys(serializedMintKeys).forEach((p) => {\n\t\tmintKeys[p] = hexToBytes(serializedMintKeys[p]);\n\t});\n\treturn mintKeys;\n}\n\nexport function deriveKeysetId(keys: MintKeys): string {\n\tconst KEYSET_VERSION = '00';\n\tconst mapBigInt = (k: [string, string]): [bigint, string] => {\n\t\treturn [BigInt(k[0]), k[1]];\n\t};\n\tconst pubkeysConcat = Object.entries(serializeMintKeys(keys))\n\t\t.map(mapBigInt)\n\t\t.sort((a, b) => (a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0))\n\t\t.map(([, pubKey]) => hexToBytes(pubKey))\n\t\t.reduce((prev, curr) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\tconst hash = sha256(pubkeysConcat);\n\tconst hashHex = Buffer.from(hash).toString('hex').slice(0, 14);\n\treturn '00' + hashHex;\n}\n\nfunction mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n"],"names":["DOMAIN_SEPARATOR","hexToBytes","hashToCurve","secret","msgToHash","sha256","Buffer","counter","maxIterations","i","counterBytes","hash","pointFromHex","bytesToHex","hash_e","pubkeys","e_","p","pointFromBytes","bytes","secp256k1","hex","getKeysetIdInt","keysetId","keysetIdInt","hexToNumber","bytesToNumber","encodeBase64toUint8","createRandomPrivateKey","serializeMintKeys","mintKeys","serializedMintKeys","deserializeMintKeys","deriveKeysetId","keys","mapBigInt","k","pubkeysConcat","a","b","pubKey","prev","curr","mergeUInt8Arrays","a1","a2","mergedArray"],"mappings":";;;;;AAqFA,MAAMA,IAAmBC,EAAW,0DAA0D;AAEvF,SAASC,EAAYC,GAA2C;AAChE,QAAAC,IAAYC,EAAOC,EAAO,OAAO,CAACN,GAAkBG,CAAM,CAAC,CAAC,GAC5DI,IAAU,IAAI,YAAY,CAAC,GAC3BC,IAAgB,KAAK;AAC3B,WAASC,IAAI,GAAGA,IAAID,GAAeC,KAAK;AACvC,UAAMC,IAAe,IAAI,WAAWH,EAAQ,MAAM,GAC5CI,IAAON,EAAOC,EAAO,OAAO,CAACF,GAAWM,CAAY,CAAC,CAAC;AACxD,QAAA;AACH,aAAOE,EAAaC,EAAWP,EAAO,OAAO,CAAC,IAAI,WAAW,CAAC,CAAI,CAAC,GAAGK,CAAI,CAAC,CAAC,CAAC;AAAA,YAC9D;AACf,MAAAJ,EAAQ,CAAC;AAAA,IAAA;AAAA,EACV;AAEK,QAAA,IAAI,MAAM,sBAAsB;AACvC;AAEO,SAASO,EAAOC,GAAmD;AAEnE,QAAAC,IADaD,EAAQ,IAAI,CAACE,MAAMA,EAAE,MAAM,EAAK,CAAC,EAC9B,KAAK,EAAE;AAEtB,SADGZ,EAAO,IAAI,cAAc,OAAOW,CAAE,CAAC;AAE9C;AAEO,SAASE,EAAeC,GAAmB;AACjD,SAAOC,EAAU,gBAAgB,QAAQP,EAAWM,CAAK,CAAC;AAC3D;AAEO,SAASP,EAAaS,GAAa;AAClC,SAAAD,EAAU,gBAAgB,QAAQC,CAAG;AAC7C;AAEa,MAAAC,IAAiB,CAACC,MAA6B;AACvD,MAAAC;AACA,SAAA,iBAAiB,KAAKD,CAAQ,IACjCC,IAAcC,EAAYF,CAAQ,IAAI,OAAO,KAAK,KAAK,CAAC,IAG1CC,IAAAE,EAAcC,EAAoBJ,CAAQ,CAAC,IAAI,OAAO,KAAK,KAAK,CAAC,GAEzEC;AACR;AAEO,SAASI,IAAyB;AACjC,SAAAR,EAAU,MAAM,iBAAiB;AACzC;AAEO,SAASS,EAAkBC,GAAwC;AACzE,QAAMC,IAAyC,CAAC;AAChD,gBAAO,KAAKD,CAAQ,EAAE,QAAQ,CAACb,MAAM;AACpC,IAAAc,EAAmBd,CAAC,IAAIJ,EAAWiB,EAASb,CAAC,CAAC;AAAA,EAAA,CAC9C,GACMc;AACR;AAEO,SAASC,EAAoBD,GAAkD;AACrF,QAAMD,IAAqB,CAAC;AAC5B,gBAAO,KAAKC,CAAkB,EAAE,QAAQ,CAACd,MAAM;AAC9C,IAAAa,EAASb,CAAC,IAAIhB,EAAW8B,EAAmBd,CAAC,CAAC;AAAA,EAAA,CAC9C,GACMa;AACR;AAEO,SAASG,EAAeC,GAAwB;AAEhD,QAAAC,IAAY,CAACC,MACX,CAAC,OAAOA,EAAE,CAAC,CAAC,GAAGA,EAAE,CAAC,CAAC,GAErBC,IAAgB,OAAO,QAAQR,EAAkBK,CAAI,CAAC,EAC1D,IAAIC,CAAS,EACb,KAAK,CAACG,GAAGC,MAAOD,EAAE,CAAC,IAAIC,EAAE,CAAC,IAAI,KAAKD,EAAE,CAAC,IAAIC,EAAE,CAAC,IAAI,IAAI,CAAE,EACvD,IAAI,CAAC,CAAA,EAAGC,CAAM,MAAMvC,EAAWuC,CAAM,CAAC,EACtC,OAAO,CAACC,GAAMC,MAASC,EAAiBF,GAAMC,CAAI,GAAG,IAAI,YAAY,GACjE/B,IAAON,EAAOgC,CAAa;AAEjC,SAAO,OADS/B,EAAO,KAAKK,CAAI,EAAE,SAAS,KAAK,EAAE,MAAM,GAAG,EAAE;AAE9D;AAEA,SAASgC,EAAiBC,GAAgBC,GAA4B;AAErE,QAAMC,IAAc,IAAI,WAAWF,EAAG,SAASC,EAAG,MAAM;AACxD,SAAAC,EAAY,IAAIF,CAAE,GACNE,EAAA,IAAID,GAAID,EAAG,MAAM,GACtBE;AACR;"}