"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const h=require("@noble/curves/secp256k1"),u=require("@noble/hashes/sha256"),s=require("@noble/curves/abstract/utils"),f=require("./util.cjs.js"),a=require("buffer"),d=s.hexToBytes("536563703235366b315f48617368546f43757276655f43617368755f");function l(e){const t=u.sha256(a.Buffer.concat([d,e])),n=new Uint32Array(1),c=2**16;for(let i=0;i<c;i++){const r=new Uint8Array(n.buffer),o=u.sha256(a.Buffer.concat([t,r]));try{return y(s.bytesToHex(a.Buffer.concat([new Uint8Array([2]),o])))}catch{n[0]++}}throw new Error("No valid point found")}function x(e){const n=e.map(i=>i.toHex(!1)).join("");return u.sha256(new TextEncoder().encode(n))}function g(e){return h.secp256k1.ProjectivePoint.fromHex(s.bytesToHex(e))}function y(e){return h.secp256k1.ProjectivePoint.fromHex(e)}const B=e=>{let t;return/^[a-fA-F0-9]+$/.test(e)?t=f.hexToNumber(e)%BigInt(2**31-1):t=f.bytesToNumber(f.encodeBase64toUint8(e))%BigInt(2**31-1),t};function b(){return h.secp256k1.utils.randomPrivateKey()}function m(e){const t={};return Object.keys(e).forEach(n=>{t[n]=s.bytesToHex(e[n])}),t}function p(e){const t={};return Object.keys(e).forEach(n=>{t[n]=s.hexToBytes(e[n])}),t}function T(e){const t=r=>[BigInt(r[0]),r[1]],n=Object.entries(m(e)).map(t).sort((r,o)=>r[0]<o[0]?-1:r[0]>o[0]?1:0).map(([,r])=>s.hexToBytes(r)).reduce((r,o)=>I(r,o),new Uint8Array),c=u.sha256(n);return"00"+a.Buffer.from(c).toString("hex").slice(0,14)}function I(e,t){const n=new Uint8Array(e.length+t.length);return n.set(e),n.set(t,e.length),n}exports.createRandomPrivateKey=b;exports.deriveKeysetId=T;exports.deserializeMintKeys=p;exports.getKeysetIdInt=B;exports.hashToCurve=l;exports.hash_e=x;exports.pointFromBytes=g;exports.pointFromHex=y;exports.serializeMintKeys=m;
//# sourceMappingURL=common.cjs.js.map
