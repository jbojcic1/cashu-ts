"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const Bt=require("./crypto/client/NUT12.cjs.js"),K=require("./crypto/common.cjs.js"),P=require("@noble/curves/abstract/utils"),Ut=require("@noble/hashes/sha256"),W=require("buffer"),D=require("./crypto/client.cjs.js"),ct=require("./crypto/client/NUT11.cjs.js"),Dt=require("./crypto/client/NUT20.cjs.js"),M=require("@noble/hashes/utils"),ut=require("./crypto/client/NUT09.cjs.js");function xt(n){return W.Buffer.from(n).toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function pt(n){return W.Buffer.from(n,"base64")}function yt(n){const t=JSON.stringify(n);return Ft(W.Buffer.from(t).toString("base64"))}function Nt(n){const t=W.Buffer.from(Ot(n),"base64").toString();return JSON.parse(t)}function Ot(n){return n.replace(/-/g,"+").replace(/_/g,"/").split("=")[0]}function Ft(n){return n.replace(/\+/g,"-").replace(/\//g,"_").split("=")[0]}function Rt(n){return typeof n=="number"||typeof n=="string"}function X(n){const t=[];return Z(n,t),new Uint8Array(t)}function Z(n,t){if(n===null)t.push(246);else if(n===void 0)t.push(247);else if(typeof n=="boolean")t.push(n?245:244);else if(typeof n=="number")mt(n,t);else if(typeof n=="string")gt(n,t);else if(Array.isArray(n))Wt(n,t);else if(n instanceof Uint8Array)Qt(n,t);else if(typeof n=="object")Ct(n,t);else throw new Error("Unsupported type")}function mt(n,t){if(n<24)t.push(n);else if(n<256)t.push(24,n);else if(n<65536)t.push(25,n>>8,n&255);else if(n<4294967296)t.push(26,n>>24,n>>16&255,n>>8&255,n&255);else throw new Error("Unsupported integer size")}function Qt(n,t){const e=n.length;if(e<24)t.push(64+e);else if(e<256)t.push(88,e);else if(e<65536)t.push(89,e>>8&255,e&255);else if(e<4294967296)t.push(90,e>>24&255,e>>16&255,e>>8&255,e&255);else throw new Error("Byte string too long to encode");for(let s=0;s<n.length;s++)t.push(n[s])}function gt(n,t){const e=new TextEncoder().encode(n),s=e.length;if(s<24)t.push(96+s);else if(s<256)t.push(120,s);else if(s<65536)t.push(121,s>>8&255,s&255);else if(s<4294967296)t.push(122,s>>24&255,s>>16&255,s>>8&255,s&255);else throw new Error("String too long to encode");for(let r=0;r<e.length;r++)t.push(e[r])}function Wt(n,t){const e=n.length;if(e<24)t.push(128|e);else if(e<256)t.push(152,e);else if(e<65536)t.push(153,e>>8,e&255);else throw new Error("Unsupported array length");for(const s of n)Z(s,t)}function Ct(n,t){const e=Object.keys(n);mt(e.length,t),t[t.length-1]|=160;for(const s of e)gt(s,t),Z(n[s],t)}function tt(n){const t=new DataView(n.buffer,n.byteOffset,n.byteLength);return C(t,0).value}function C(n,t){if(t>=n.byteLength)throw new Error("Unexpected end of data");const e=n.getUint8(t++),s=e>>5,r=e&31;switch(s){case 0:return Lt(n,t,r);case 1:return Ht(n,t,r);case 2:return jt(n,t,r);case 3:return zt(n,t,r);case 4:return $t(n,t,r);case 5:return Gt(n,t,r);case 7:return Jt(n,t,r);default:throw new Error(`Unsupported major type: ${s}`)}}function R(n,t,e){if(e<24)return{value:e,offset:t};if(e===24)return{value:n.getUint8(t++),offset:t};if(e===25){const s=n.getUint16(t,!1);return t+=2,{value:s,offset:t}}if(e===26){const s=n.getUint32(t,!1);return t+=4,{value:s,offset:t}}if(e===27){const s=n.getUint32(t,!1),r=n.getUint32(t+4,!1);return t+=8,{value:s*2**32+r,offset:t}}throw new Error(`Unsupported length: ${e}`)}function Lt(n,t,e){const{value:s,offset:r}=R(n,t,e);return{value:s,offset:r}}function Ht(n,t,e){const{value:s,offset:r}=R(n,t,e);return{value:-1-s,offset:r}}function jt(n,t,e){const{value:s,offset:r}=R(n,t,e);if(r+s>n.byteLength)throw new Error("Byte string length exceeds data length");return{value:new Uint8Array(n.buffer,n.byteOffset+r,s),offset:r+s}}function zt(n,t,e){const{value:s,offset:r}=R(n,t,e);if(r+s>n.byteLength)throw new Error("String length exceeds data length");const o=new Uint8Array(n.buffer,n.byteOffset+r,s);return{value:new TextDecoder().decode(o),offset:r+s}}function $t(n,t,e){const{value:s,offset:r}=R(n,t,e),o=[];let a=r;for(let i=0;i<s;i++){const c=C(n,a);o.push(c.value),a=c.offset}return{value:o,offset:a}}function Gt(n,t,e){const{value:s,offset:r}=R(n,t,e),o={};let a=r;for(let i=0;i<s;i++){const c=C(n,a);if(!Rt(c.value))throw new Error("Invalid key type");const u=C(n,c.offset);o[c.value]=u.value,a=u.offset}return{value:o,offset:a}}function Vt(n){const t=(n&31744)>>10,e=n&1023,s=n&32768?-1:1;return t===0?s*2**-14*(e/1024):t===31?e?NaN:s*(1/0):s*2**(t-15)*(1+e/1024)}function Jt(n,t,e){if(e<24)switch(e){case 20:return{value:!1,offset:t};case 21:return{value:!0,offset:t};case 22:return{value:null,offset:t};case 23:return{value:void 0,offset:t};default:throw new Error(`Unknown simple value: ${e}`)}if(e===24)return{value:n.getUint8(t++),offset:t};if(e===25){const s=Vt(n.getUint16(t,!1));return t+=2,{value:s,offset:t}}if(e===26){const s=n.getFloat32(t,!1);return t+=4,{value:s,offset:t}}if(e===27){const s=n.getFloat64(t,!1);return t+=8,{value:s,offset:t}}throw new Error(`Unknown simple or float value: ${e}`)}class j{constructor(t,e,s,r,o,a,i=!1,c){this.transport=t,this.id=e,this.amount=s,this.unit=r,this.mints=o,this.description=a,this.singleUse=i,this.nut10=c}toRawRequest(){const t={};return this.transport&&(t.t=this.transport.map(e=>({t:e.type,a:e.target,g:e.tags}))),this.id&&(t.i=this.id),this.amount&&(t.a=this.amount),this.unit&&(t.u=this.unit),this.mints&&(t.m=this.mints),this.description&&(t.d=this.description),this.singleUse&&(t.s=this.singleUse),this.nut10&&(t.nut10={k:this.nut10.kind,d:this.nut10.data,t:this.nut10.tags}),t}toEncodedRequest(){const t=this.toRawRequest(),e=X(t);return"creqA"+W.Buffer.from(e).toString("base64")}getTransport(t){return this.transport?.find(e=>e.type===t)}static fromRawRequest(t){const e=t.t?t.t.map(r=>({type:r.t,target:r.a,tags:r.g})):void 0,s=t.nut10?{kind:t.nut10.k,data:t.nut10.d,tags:t.nut10.t}:void 0;return new j(e,t.i,t.a,t.u,t.m,t.d,t.s,s)}static fromEncodedRequest(t){if(!t.startsWith("creq"))throw new Error("unsupported pr: invalid prefix");if(t[4]!=="A")throw new Error("unsupported pr version");const s=t.slice(5),r=pt(s),o=tt(r);return this.fromRawRequest(o)}}const Yt="A",Xt="cashu";function A(n,t,e,s){if(e){const o=lt(e);if(o>n)throw new Error(`Split is greater than total amount: ${o} > ${n}`);if(e.some(a=>!kt(a,t)))throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");n=n-lt(e)}else e=[];return wt(t,"desc").forEach(o=>{const a=Math.floor(n/o);for(let i=0;i<a;++i)e?.push(o);n%=o}),e.sort((o,a)=>o-a)}function ht(n,t,e,s){const r=[],o=n.map(u=>u.amount);wt(e,"asc").forEach(u=>{const d=o.filter(y=>y===u).length,f=Math.max(s-d,0);for(let y=0;y<f&&!(r.reduce((h,l)=>h+l,0)+u>t);++y)r.push(u)});const i=t-r.reduce((u,d)=>u+d,0);return i&&A(i,e).forEach(d=>{r.push(d)}),r.sort((u,d)=>u-d)}function wt(n,t="desc"){return t=="desc"?Object.keys(n).map(e=>parseInt(e)).sort((e,s)=>s-e):Object.keys(n).map(e=>parseInt(e)).sort((e,s)=>e-s)}function kt(n,t){return n in t}function Zt(n){return _t(P.bytesToHex(n))}function _t(n){return BigInt(`0x${n}`)}function te(n){return n.toString(16).padStart(64,"0")}function dt(n){return/^[a-f0-9]*$/i.test(n)}function bt(n){return Array.isArray(n)?n.some(t=>!dt(t.id)):dt(n.id)}function ee(n,t){t&&(n.proofs=L(n.proofs));const e={token:[{mint:n.mint,proofs:n.proofs}]};return n.unit&&(e.unit=n.unit),n.memo&&(e.memo=n.memo),Xt+Yt+yt(e)}function se(n,t){if(bt(n.proofs)||t?.version===3){if(t?.version===4)throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");return ee(n,t?.removeDleq)}return Et(n,t?.removeDleq)}function Et(n,t){if(t&&(n.proofs=L(n.proofs)),n.proofs.forEach(c=>{if(c.dleq&&c.dleq.r==null)throw new Error("Missing blinding factor in included DLEQ proof")}),bt(n.proofs))throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");const s=St(n),r=X(s),o="cashu",a="B",i=xt(r);return o+a+i}function St(n){const t={},e=n.mint;for(let r=0;r<n.proofs.length;r++){const o=n.proofs[r];t[o.id]?t[o.id].push(o):t[o.id]=[o]}const s={m:e,u:n.unit||"sat",t:Object.keys(t).map(r=>({i:P.hexToBytes(r),p:t[r].map(o=>({a:o.amount,s:o.secret,c:P.hexToBytes(o.C),...o.dleq&&{d:{e:P.hexToBytes(o.dleq.e),s:P.hexToBytes(o.dleq.s),r:P.hexToBytes(o.dleq.r??"00")}},...o.witness&&{w:JSON.stringify(o.witness)}}))}))};return n.memo&&(s.d=n.memo),s}function Pt(n){const t=[];n.t.forEach(s=>s.p.forEach(r=>{t.push({secret:r.s,C:P.bytesToHex(r.c),amount:r.a,id:P.bytesToHex(s.i),...r.d&&{dleq:{r:P.bytesToHex(r.d.r),s:P.bytesToHex(r.d.s),e:P.bytesToHex(r.d.e)}},...r.w&&{witness:r.w}})}));const e={mint:n.m,proofs:t,unit:n.u||"sat"};return n.d&&(e.memo=n.d),e}function At(n){return["web+cashu://","cashu://","cashu:","cashu"].forEach(e=>{n.startsWith(e)&&(n=n.slice(e.length))}),ne(n)}function ne(n){const t=n.slice(0,1),e=n.slice(1);if(t==="A"){const s=Nt(e);if(s.token.length>1)throw new Error("Multi entry token are not supported");const r=s.token[0],o={mint:r.mint,proofs:r.proofs,unit:s.unit||"sat"};return s.memo&&(o.memo=s.memo),o}else if(t==="B"){const s=pt(e),r=tt(s);return Pt(r)}throw new Error("Token version is not supported")}function re(n){const t=Object.entries(n).sort((r,o)=>+r[0]-+o[0]).map(([,r])=>P.hexToBytes(r)).reduce((r,o)=>oe(r,o),new Uint8Array),e=Ut.sha256(t);return"00"+Buffer.from(e).toString("hex").slice(0,14)}function oe(n,t){const e=new Uint8Array(n.length+t.length);return e.set(n),e.set(t,n.length),e}function v(n){return typeof n=="object"}function _(...n){return n.map(t=>t.replace(/(^\/+|\/+$)/g,"")).join("/")}function qt(n){return n.replace(/\/$/,"")}function U(n){return n.reduce((t,e)=>t+e.amount,0)}function ie(n){return j.fromEncodedRequest(n)}class ae{get value(){return this._value}set value(t){this._value=t}get next(){return this._next}set next(t){this._next=t}constructor(t){this._value=t,this._next=null}}class ce{get first(){return this._first}set first(t){this._first=t}get last(){return this._last}set last(t){this._last=t}get size(){return this._size}set size(t){this._size=t}constructor(){this._first=null,this._last=null,this._size=0}enqueue(t){const e=new ae(t);return this._size===0||!this._last?(this._first=e,this._last=e):(this._last.next=e,this._last=e),this._size++,!0}dequeue(){if(this._size===0||!this._first)return null;const t=this._first;return this._first=t.next,t.next=null,this._size--,t.value}}function L(n){return n.map(t=>{const e={...t};return delete e.dleq,e})}function et(n,t){if(n.dleq==null)return!1;const e={e:P.hexToBytes(n.dleq.e),s:P.hexToBytes(n.dleq.s),r:_t(n.dleq.r??"00")};if(!kt(n.amount,t.keys))throw new Error(`undefined key for amount ${n.amount}`);const s=t.keys[n.amount];return!!Bt.verifyDLEQProof_reblind(new TextEncoder().encode(n.secret),e,K.pointFromHex(n.C),K.pointFromHex(s))}function ue(...n){const t=n.reduce((r,o)=>r+o.length,0),e=new Uint8Array(t);let s=0;for(let r=0;r<n.length;r++)e.set(n[r],s),s=s+n[r].length;return e}function he(n){const t=new TextEncoder,e=St(n),s=X(e),r=t.encode("craw"),o=t.encode("B");return ue(r,o,s)}function de(n){const t=new TextDecoder,e=t.decode(n.slice(0,4)),s=t.decode(new Uint8Array([n[4]]));if(e!=="craw"||s!=="B")throw new Error("not a valid binary token");const r=n.slice(5),o=tt(r);return Pt(o)}function lt(n){return n.reduce((t,e)=>t+e,0)}let st;typeof WebSocket<"u"&&(st=WebSocket);function le(n){st=n}function fe(){return st}class x{constructor(){this.connectionMap=new Map}static getInstance(){return x.instace||(x.instace=new x),x.instace}getConnection(t){if(this.connectionMap.has(t))return this.connectionMap.get(t);const e=new pe(t);return this.connectionMap.set(t,e),e}}class pe{constructor(t){this.subListeners={},this.rpcListeners={},this.rpcId=0,this.onCloseCallbacks=[],this._WS=fe(),this.url=new URL(t),this.messageQueue=new ce}connect(){return this.connectionPromise||(this.connectionPromise=new Promise((t,e)=>{try{this.ws=new this._WS(this.url.toString()),this.onCloseCallbacks=[]}catch(s){e(s);return}this.ws.onopen=()=>{t()},this.ws.onerror=()=>{e(new Error("Failed to open WebSocket"))},this.ws.onmessage=s=>{this.messageQueue.enqueue(s.data),this.handlingInterval||(this.handlingInterval=setInterval(this.handleNextMesage.bind(this),0))},this.ws.onclose=s=>{this.connectionPromise=void 0,this.onCloseCallbacks.forEach(r=>r(s))}})),this.connectionPromise}sendRequest(t,e){if(this.ws?.readyState!==1){if(t==="unsubscribe")return;throw new Error("Socket not open...")}const s=this.rpcId;this.rpcId++;const r=JSON.stringify({jsonrpc:"2.0",method:t,params:e,id:s});this.ws?.send(r)}closeSubscription(t){this.ws?.send(JSON.stringify(["CLOSE",t]))}addSubListener(t,e){(this.subListeners[t]=this.subListeners[t]||[]).push(e)}addRpcListener(t,e,s){this.rpcListeners[s]={callback:t,errorCallback:e}}removeRpcListener(t){delete this.rpcListeners[t]}removeListener(t,e){if(this.subListeners[t]){if(this.subListeners[t].length===1){delete this.subListeners[t];return}this.subListeners[t]=this.subListeners[t].filter(s=>s!==e)}}async ensureConnection(){this.ws?.readyState!==1&&await this.connect()}handleNextMesage(){if(this.messageQueue.size===0){clearInterval(this.handlingInterval),this.handlingInterval=void 0;return}const t=this.messageQueue.dequeue();let e;try{if(e=JSON.parse(t),"result"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].callback(),this.removeRpcListener(e.id));else if("error"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].errorCallback(e.error),this.removeRpcListener(e.id));else if("method"in e&&!("id"in e)){const s=e.params.subId;if(!s)return;if(this.subListeners[s]?.length>0){const r=e;this.subListeners[s].forEach(o=>o(r.params.payload))}}}catch(s){console.error(s);return}}createSubscription(t,e,s){if(this.ws?.readyState!==1)return s(new Error("Socket is not open"));const r=(Math.random()+1).toString(36).substring(7);return this.addRpcListener(()=>{this.addSubListener(r,e)},o=>{s(new Error(o.message))},this.rpcId),this.sendRequest("subscribe",{...t,subId:r}),this.rpcId++,r}cancelSubscription(t,e){this.removeRpcListener(t),this.removeListener(t,e),this.rpcId++,this.sendRequest("unsubscribe",{subId:t})}get activeSubscriptions(){return Object.keys(this.subListeners)}close(){this.ws&&this.ws?.close()}onClose(t){this.onCloseCallbacks.push(t)}}const ye={UNSPENT:"UNSPENT",PENDING:"PENDING",SPENT:"SPENT"},O={UNPAID:"UNPAID",PENDING:"PENDING",PAID:"PAID"},H={UNPAID:"UNPAID",PAID:"PAID",ISSUED:"ISSUED"};var Tt=(n=>(n.POST="post",n.NOSTR="nostr",n))(Tt||{});class F extends Error{constructor(t,e){super(t),this.status=e,this.name="HttpResponseError",Object.setPrototypeOf(this,F.prototype)}}class z extends Error{constructor(t){super(t),this.name="NetworkError",Object.setPrototypeOf(this,z.prototype)}}class $ extends F{constructor(t,e){super(e||"Unknown mint operation error",400),this.code=t,this.name="MintOperationError",Object.setPrototypeOf(this,$.prototype)}}let It={};function me(n){It=n}async function ge({endpoint:n,requestBody:t,headers:e,...s}){const r=t?JSON.stringify(t):void 0,o={Accept:"application/json, text/plain, */*",...r?{"Content-Type":"application/json"}:void 0,...e};let a;try{a=await fetch(n,{body:r,headers:o,...s})}catch(i){throw new z(i instanceof Error?i.message:"Network request failed")}if(!a.ok){const i=await a.json().catch(()=>({error:"bad response"}));throw a.status===400&&"code"in i&&"detail"in i?new $(i.code,i.detail):new F("error"in i?i.error:i.detail||"HTTP request failed",a.status)}try{return await a.json()}catch(i){throw console.error("Failed to parse HTTP response",i),new F("bad response",a.status)}}async function S(n){return await ge({...n,...It})}function G(n){return n.state||(console.warn("Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"),typeof n.paid=="boolean"&&(n.state=n.paid?O.PAID:O.UNPAID)),n}function ft(n){return n.state||(console.warn("Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"),typeof n.paid=="boolean"&&(n.state=n.paid?H.PAID:H.UNPAID)),n}function we(n){return Array.isArray(n?.contact)&&n?.contact.length>0&&(n.contact=n.contact.map(t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="string"&&typeof t[1]=="string"?(console.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"),{method:t[0],info:t[1]}):t)),n}class Y{constructor(t){this._mintInfo=t,t.nuts[22]&&(this._protectedEnpoints={cache:{},apiReturn:t.nuts[22].protected_endpoints.map(e=>({method:e.method,regex:new RegExp(e.path)}))})}isSupported(t){switch(t){case 4:case 5:return this.checkMintMelt(t);case 7:case 8:case 9:case 10:case 11:case 12:case 14:case 20:return this.checkGenericNut(t);case 17:return this.checkNut17();case 15:return this.checkNut15();default:throw new Error("nut is not supported by cashu-ts")}}requiresBlindAuthToken(t){if(!this._protectedEnpoints)return!1;if(typeof this._protectedEnpoints.cache[t]=="boolean")return this._protectedEnpoints.cache[t];const e=this._protectedEnpoints.apiReturn.some(s=>s.regex.test(t));return this._protectedEnpoints.cache[t]=e,e}checkGenericNut(t){return this._mintInfo.nuts[t]?.supported?{supported:!0}:{supported:!1}}checkMintMelt(t){const e=this._mintInfo.nuts[t];return e&&e.methods.length>0&&!e.disabled?{disabled:!1,params:e.methods}:{disabled:!0,params:e.methods}}checkNut17(){return this._mintInfo.nuts[17]&&this._mintInfo.nuts[17].supported.length>0?{supported:!0,params:this._mintInfo.nuts[17].supported}:{supported:!1}}checkNut15(){return this._mintInfo.nuts[15]&&this._mintInfo.nuts[15].methods.length>0?{supported:!0,params:this._mintInfo.nuts[15].methods}:{supported:!1}}get contact(){return this._mintInfo.contact}get description(){return this._mintInfo.description}get description_long(){return this._mintInfo.description_long}get name(){return this._mintInfo.name}get pubkey(){return this._mintInfo.pubkey}get nuts(){return this._mintInfo.nuts}get version(){return this._mintInfo.version}get motd(){return this._mintInfo.motd}}class E{constructor(t,e,s){this._mintUrl=t,this._customRequest=e,this._checkNut22=!1,this._mintUrl=qt(t),this._customRequest=e,s&&(this._checkNut22=!0,this._authTokenGetter=s)}get mintUrl(){return this._mintUrl}static async getInfo(t,e){const r=await(e||S)({endpoint:_(t,"/v1/info")});return we(r)}async getInfo(){return E.getInfo(this._mintUrl,this._customRequest)}async getLazyMintInfo(){if(this._mintInfo)return this._mintInfo;const t=await E.getInfo(this._mintUrl,this._customRequest);return this._mintInfo=new Y(t),this._mintInfo}static async swap(t,e,s,r){const o=s||S,a=r?{"Blind-auth":r}:{},i=await o({endpoint:_(t,"/v1/swap"),method:"POST",requestBody:e,headers:a});if(!v(i)||!Array.isArray(i?.signatures))throw new Error(i.detail??"bad response");return i}async swap(t){const e=await this.handleBlindAuth("/v1/swap");return E.swap(this._mintUrl,t,this._customRequest,e)}static async createMintQuote(t,e,s,r){const o=s||S,a=r?{"Blind-auth":r}:{},i=await o({endpoint:_(t,"/v1/mint/quote/bolt11"),method:"POST",requestBody:e,headers:a});return ft(i)}async createMintQuote(t){const e=await this.handleBlindAuth("/v1/mint/quote/bolt11");return E.createMintQuote(this._mintUrl,t,this._customRequest,e)}static async checkMintQuote(t,e,s,r){const o=s||S,a=r?{"Blind-auth":r}:{},i=await o({endpoint:_(t,"/v1/mint/quote/bolt11",e),method:"GET",headers:a});return ft(i)}async checkMintQuote(t){const e=await this.handleBlindAuth(`/v1/mint/quote/bolt11/${t}`);return E.checkMintQuote(this._mintUrl,t,this._customRequest,e)}static async mint(t,e,s,r){const o=s||S,a=r?{"Blind-auth":r}:{},i=await o({endpoint:_(t,"/v1/mint/bolt11"),method:"POST",requestBody:e,headers:a});if(!v(i)||!Array.isArray(i?.signatures))throw new Error("bad response");return i}async mint(t){const e=await this.handleBlindAuth("/v1/mint/bolt11");return E.mint(this._mintUrl,t,this._customRequest,e)}static async createMeltQuote(t,e,s,r){const o=s||S,a=r?{"Blind-auth":r}:{},i=await o({endpoint:_(t,"/v1/melt/quote/bolt11"),method:"POST",requestBody:e,headers:a}),c=G(i);if(!v(c)||typeof c?.amount!="number"||typeof c?.fee_reserve!="number"||typeof c?.quote!="string")throw new Error("bad response");return c}async createMeltQuote(t){const e=await this.handleBlindAuth("/v1/melt/quote/bolt11");return E.createMeltQuote(this._mintUrl,t,this._customRequest,e)}static async checkMeltQuote(t,e,s,r){const o=s||S,a=r?{"Blind-auth":r}:{},i=await o({endpoint:_(t,"/v1/melt/quote/bolt11",e),method:"GET",headers:a}),c=G(i);if(!v(c)||typeof c?.amount!="number"||typeof c?.fee_reserve!="number"||typeof c?.quote!="string"||typeof c?.state!="string"||!Object.values(O).includes(c.state))throw new Error("bad response");return c}async checkMeltQuote(t){const e=await this.handleBlindAuth(`/v1/melt/quote/bolt11/${t}`);return E.checkMeltQuote(this._mintUrl,t,this._customRequest,e)}static async melt(t,e,s,r){const o=s||S,a=r?{"Blind-auth":r}:{},i=await o({endpoint:_(t,"/v1/melt/bolt11"),method:"POST",requestBody:e,headers:a}),c=G(i);if(!v(c)||typeof c?.state!="string"||!Object.values(O).includes(c.state))throw new Error("bad response");return c}async melt(t){const e=await this.handleBlindAuth("/v1/melt/bolt11");return E.melt(this._mintUrl,t,this._customRequest,e)}static async check(t,e,s){const o=await(s||S)({endpoint:_(t,"/v1/checkstate"),method:"POST",requestBody:e});if(!v(o)||!Array.isArray(o?.states))throw new Error("bad response");return o}static async getKeys(t,e,s){e&&(e=e.replace(/\//g,"_").replace(/\+/g,"-"));const o=await(s||S)({endpoint:e?_(t,"/v1/keys",e):_(t,"/v1/keys")});if(!v(o)||!Array.isArray(o.keysets))throw new Error("bad response");return o}async getKeys(t,e){return await E.getKeys(e||this._mintUrl,t,this._customRequest)}static async getKeySets(t,e){return(e||S)({endpoint:_(t,"/v1/keysets")})}async getKeySets(){return E.getKeySets(this._mintUrl,this._customRequest)}async check(t){return E.check(this._mintUrl,t,this._customRequest)}static async restore(t,e,s){const o=await(s||S)({endpoint:_(t,"/v1/restore"),method:"POST",requestBody:e});if(!v(o)||!Array.isArray(o?.outputs)||!Array.isArray(o?.signatures))throw new Error("bad response");return o}async restore(t){return E.restore(this._mintUrl,t,this._customRequest)}async connectWebSocket(){if(this.ws)await this.ws.ensureConnection();else{const t=new URL(this._mintUrl),e="v1/ws";t.pathname&&(t.pathname.endsWith("/")?t.pathname+=e:t.pathname+="/"+e),this.ws=x.getInstance().getConnection(`${t.protocol==="https:"?"wss":"ws"}://${t.host}${t.pathname}`);try{await this.ws.connect()}catch(s){throw console.log(s),new Error("Failed to connect to WebSocket...")}}}disconnectWebSocket(){this.ws&&this.ws.close()}get webSocketConnection(){return this.ws}async handleBlindAuth(t){if(!this._checkNut22)return;if((await this.getLazyMintInfo()).requiresBlindAuthToken(t)){if(!this._authTokenGetter)throw new Error("Can not call a protected endpoint without authProofGetter");return this._authTokenGetter()}}}class V{constructor(t,e,s){this.amount=t,this.B_=e,this.id=s}getSerializedBlindedMessage(){return{amount:this.amount,B_:this.B_.toHex(!0),id:this.id}}}function J(n){return typeof n=="function"}class I{constructor(t,e,s){this.secret=s,this.blindingFactor=e,this.blindedMessage=t}toProof(t,e){let s;t.dleq&&(s={s:M.hexToBytes(t.dleq.s),e:M.hexToBytes(t.dleq.e),r:this.blindingFactor});const r={id:t.id,amount:t.amount,C_:K.pointFromHex(t.C_),dleq:s},o=K.pointFromHex(e.keys[t.amount]),a=D.constructProofFromPromise(r,this.blindingFactor,this.secret,o);return{...D.serializeProof(a),...s&&{dleq:{s:M.bytesToHex(s.s),e:M.bytesToHex(s.e),r:te(s.r??BigInt(0))}}}}static createP2PKData(t,e,s,r){return A(e,s.keys,r).map(a=>this.createSingleP2PKData(t,a,s.id))}static createSingleP2PKData(t,e,s){const r=["P2PK",{nonce:M.bytesToHex(M.randomBytes(32)),data:t.pubkey,tags:[]}];t.locktime&&r[1].tags.push(["locktime",t.locktime]),t.refundKeys&&r[1].tags.push(["refund",...t.refundKeys]);const o=JSON.stringify(r),a=new TextEncoder().encode(o),{r:i,B_:c}=D.blindMessage(a);return new I(new V(e,c,s).getSerializedBlindedMessage(),i,a)}static createRandomData(t,e,s){return A(t,e.keys,s).map(o=>this.createSingleRandomData(o,e.id))}static createSingleRandomData(t,e){const s=M.bytesToHex(M.randomBytes(32)),r=new TextEncoder().encode(s),{r:o,B_:a}=D.blindMessage(r);return new I(new V(t,a,e).getSerializedBlindedMessage(),o,r)}static createDeterministicData(t,e,s,r,o){return A(t,r.keys,o).map((i,c)=>this.createSingleDeterministicData(i,e,s+c,r.id))}static createSingleDeterministicData(t,e,s,r){const o=ut.deriveSecret(e,r,s),a=M.bytesToHex(o),i=new TextEncoder().encode(a),c=Zt(ut.deriveBlindingFactor(e,r,s)),{r:u,B_:d}=D.blindMessage(i,c);return new I(new V(t,d,r).getSerializedBlindedMessage(),u,i)}}const ke=3,_e="sat";class be{constructor(t,e){this._keys=new Map,this._keysets=[],this._seed=void 0,this._unit=_e,this._mintInfo=void 0,this._denominationTarget=ke,this.mint=t;let s=[];if(e?.keys&&!Array.isArray(e.keys)?s=[e.keys]:e?.keys&&Array.isArray(e?.keys)&&(s=e?.keys),s&&s.forEach(r=>this._keys.set(r.id,r)),e?.unit&&(this._unit=e?.unit),e?.keysets&&(this._keysets=e.keysets),e?.mintInfo&&(this._mintInfo=new Y(e.mintInfo)),e?.denominationTarget&&(this._denominationTarget=e.denominationTarget),e?.bip39seed){if(e.bip39seed instanceof Uint8Array){this._seed=e.bip39seed;return}throw new Error("bip39seed must be a valid UInt8Array")}e?.keepFactory&&(this._keepFactory=e.keepFactory)}get unit(){return this._unit}get keys(){return this._keys}get keysetId(){if(!this._keysetId)throw new Error("No keysetId set");return this._keysetId}set keysetId(t){this._keysetId=t}get keysets(){return this._keysets}get mintInfo(){if(!this._mintInfo)throw new Error("Mint info not loaded");return this._mintInfo}async getMintInfo(){const t=await this.mint.getInfo();return this._mintInfo=new Y(t),this._mintInfo}async lazyGetMintInfo(){return this._mintInfo?this._mintInfo:await this.getMintInfo()}async loadMint(){await this.getMintInfo(),await this.getKeySets(),await this.getKeys()}getActiveKeyset(t){let e=t.filter(r=>r.active&&r.unit===this._unit);e=e.filter(r=>r.id.startsWith("00"));const s=e.sort((r,o)=>(r.input_fee_ppk??0)-(o.input_fee_ppk??0))[0];if(!s)throw new Error("No active keyset found");return s}async getKeySets(){const e=(await this.mint.getKeySets()).keysets.filter(s=>s.unit===this._unit);return this._keysets=e,this._keysets}async getAllKeys(){const t=await this.mint.getKeys();return this._keys=new Map(t.keysets.map(e=>[e.id,e])),this.keysetId=this.getActiveKeyset(this._keysets).id,t.keysets}async getKeys(t,e){if((!(this._keysets.length>0)||e)&&await this.getKeySets(),t||(t=this.getActiveKeyset(this._keysets).id),!this._keysets.find(s=>s.id===t)&&(await this.getKeySets(),!this._keysets.find(s=>s.id===t)))throw new Error(`could not initialize keys. No keyset with id '${t}' found`);if(!this._keys.get(t)){const s=await this.mint.getKeys(t);this._keys.set(t,s.keysets[0])}return this.keysetId=t,this._keys.get(t)}async receive(t,e){const{requireDleq:s,keysetId:r,outputAmounts:o,counter:a,pubkey:i,privkey:c,outputData:u,p2pk:d}=e||{};typeof t=="string"&&(t=At(t));const f=await this.getKeys(r);if(s&&t.proofs.some(k=>!et(k,f)))throw new Error("Token contains proofs with invalid DLEQ");const y=U(t.proofs)-this.getFeesForProofs(t.proofs);let h;u?h={send:u}:this._keepFactory&&(h={send:this._keepFactory});const l=this.createSwapPayload(y,t.proofs,f,o,a,i,c,h,d),{signatures:w}=await this.mint.swap(l.payload),m=l.outputData.map((k,p)=>k.toProof(w[p],f)),g=[];return l.sortedIndices.forEach((k,p)=>{g[k]=m[p]}),g}async send(t,e,s){const{proofsWeHave:r,offline:o,includeFees:a,includeDleq:i,keysetId:c,outputAmounts:u,pubkey:d,privkey:f,outputData:y}=s||{};if(i&&(e=e.filter(m=>m.dleq!=null)),U(e)<t)throw new Error("Not enough funds available to send");const{keep:h,send:l}=this.selectProofsToSend(e,t,s?.includeFees),w=a?this.getFeesForProofs(l):0;if(!o&&(U(l)!=t+w||u||d||f||c||y)){const{keep:m,send:g}=this.selectProofsToSend(e,t,!0);r?.push(...m);const k=await this.swap(t,g,s);let{keep:p,send:T}=k;const B=k.serialized;return p=m.concat(p),{keep:p,send:T,serialized:B}}if(U(l)<t+w)throw new Error("Not enough funds available to send");return{keep:h,send:l}}selectProofsToSend(t,e,s){const r=t.sort((h,l)=>h.amount-l.amount),o=r.filter(h=>h.amount<=e).sort((h,l)=>l.amount-h.amount),i=r.filter(h=>h.amount>e).sort((h,l)=>h.amount-l.amount)[0];if(!o.length&&i)return{keep:t.filter(h=>h.secret!==i.secret),send:[i]};if(!o.length&&!i)return{keep:t,send:[]};let c=e,u=[o[0]];const d=[],f=s?this.getProofFeePPK(u[0]):0;if(c-=u[0].amount-f/1e3,c>0){const{keep:h,send:l}=this.selectProofsToSend(o.slice(1),c,s);u.push(...l),d.push(...h)}const y=s?this.getFeesForProofs(u):0;return U(u)<e+y&&i&&(u=[i]),{keep:t.filter(h=>!u.includes(h)),send:u}}getFeesForProofs(t){const e=t.reduce((s,r)=>s+this.getProofFeePPK(r),0);return Math.ceil(e/1e3)}getProofFeePPK(t){const e=this._keysets.find(s=>s.id===t.id);if(!e)throw new Error(`Could not get fee. No keyset found for keyset id: ${t.id}`);return e?.input_fee_ppk||0}getFeesForKeyset(t,e){return Math.floor(Math.max((t*(this._keysets.find(r=>r.id===e)?.input_fee_ppk||0)+999)/1e3,0))}async swap(t,e,s){let{outputAmounts:r}=s||{};const{includeFees:o,keysetId:a,counter:i,pubkey:c,privkey:u,proofsWeHave:d,outputData:f,p2pk:y}=s||{},h=await this.getKeys(a),l=e;let w=t;const m=U(e);let g=m-w-this.getFeesForProofs(l),k=r?.sendAmounts||A(w,h.keys);if(o){let b=this.getFeesForKeyset(k.length,h.id),q=A(b,h.keys);for(;this.getFeesForKeyset(k.concat(q).length,h.id)>b;)b++,q=A(b,h.keys);k=k.concat(q),w+=b,g-=b}let p;if(!r?.keepAmounts&&d)p=ht(d,g,h.keys,this._denominationTarget);else if(r){if(r.keepAmounts?.reduce((b,q)=>b+q,0)!=g)throw new Error("Keep amounts do not match amount to keep");p=r.keepAmounts}if(w+this.getFeesForProofs(l)>m)throw console.error(`Not enough funds available (${m}) for swap amountToSend: ${w} + fee: ${this.getFeesForProofs(l)} | length: ${l.length}`),new Error("Not enough funds available for swap");if(w+this.getFeesForProofs(l)+g!=m)throw new Error("Amounts do not match for swap");r={keepAmounts:p,sendAmounts:k};const T=f?.keep||this._keepFactory,B=f?.send,Q=this.createSwapPayload(w,l,h,r,i,c,u,{keep:T,send:B},y),{signatures:Kt}=await this.mint.swap(Q.payload),nt=Q.outputData.map((b,q)=>b.toProof(Kt[q],h)),rt=[],ot=[],it=Array(Q.keepVector.length),at=Array(nt.length);return Q.sortedIndices.forEach((b,q)=>{it[b]=Q.keepVector[q],at[b]=nt[q]}),at.forEach((b,q)=>{it[q]?rt.push(b):ot.push(b)}),{keep:rt,send:ot}}async batchRestore(t=300,e=100,s=0,r){const o=Math.ceil(t/e),a=[];let i,c=0;for(;c<o;){const u=await this.restore(s,e,{keysetId:r});u.proofs.length>0?(c=0,a.push(...u.proofs),i=u.lastCounterWithSignature):c++,s+=e}return{proofs:a,lastCounterWithSignature:i}}async restore(t,e,s){const{keysetId:r}=s||{},o=await this.getKeys(r);if(!this._seed)throw new Error("CashuWallet must be initialized with a seed to use restore");const a=Array(e).fill(1),i=I.createDeterministicData(a.length,this._seed,t,o,a),{outputs:c,signatures:u}=await this.mint.restore({outputs:i.map(h=>h.blindedMessage)}),d={};c.forEach((h,l)=>d[h.B_]=u[l]);const f=[];let y;for(let h=0;h<i.length;h++){const l=d[i[h].blindedMessage.B_];l&&(y=t+h,i[h].blindedMessage.amount=l.amount,f.push(i[h].toProof(l,o)))}return{proofs:f,lastCounterWithSignature:y}}async createMintQuote(t,e){const s={unit:this._unit,amount:t,description:e},r=await this.mint.createMintQuote(s);return{...r,amount:r.amount||t,unit:r.unit||this.unit}}async createLockedMintQuote(t,e,s){const{supported:r}=(await this.getMintInfo()).isSupported(20);if(!r)throw new Error("Mint does not support NUT-20");const o={unit:this._unit,amount:t,description:s,pubkey:e},a=await this.mint.createMintQuote(o);if(typeof a.pubkey!="string")throw new Error("Mint returned unlocked mint quote");{const i=a.pubkey;return{...a,pubkey:i,amount:a.amount||t,unit:a.unit||this.unit}}}async checkMintQuote(t){const e=typeof t=="string"?t:t.quote,s=await this.mint.checkMintQuote(e);return typeof t=="string"?s:{...s,amount:s.amount||t.amount,unit:s.unit||t.unit}}async mintProofs(t,e,s){let{outputAmounts:r}=s||{};const{counter:o,pubkey:a,p2pk:i,keysetId:c,proofsWeHave:u,outputData:d,privateKey:f}=s||{},y=await this.getKeys(c);!r&&u&&(r={keepAmounts:ht(u,t,y.keys,this._denominationTarget),sendAmounts:[]});let h=[];if(d)if(J(d)){const m=A(t,y.keys,r?.keepAmounts);for(let g=0;g<m.length;g++)h.push(d(m[g],y))}else h=d;else if(this._keepFactory){const m=A(t,y.keys,r?.keepAmounts);for(let g=0;g<m.length;g++)h.push(this._keepFactory(m[g],y))}else h=this.createOutputData(t,y,o,a,r?.keepAmounts,i);let l;if(typeof e!="string"){if(!f)throw new Error("Can not sign locked quote without private key");const m=h.map(k=>k.blindedMessage),g=Dt.signMintQuote(f,e.quote,m);l={outputs:m,quote:e.quote,signature:g}}else l={outputs:h.map(m=>m.blindedMessage),quote:e};const{signatures:w}=await this.mint.mint(l);return h.map((m,g)=>m.toProof(w[g],y))}async createMeltQuote(t){const e={unit:this._unit,request:t},s=await this.mint.createMeltQuote(e);return{...s,unit:s.unit||this.unit,request:s.request||t}}async createMultiPathMeltQuote(t,e){const{supported:s,params:r}=(await this.lazyGetMintInfo()).isSupported(15);if(!s)throw new Error("Mint does not support NUT-15");if(!r?.some(u=>u.method==="bolt11"&&u.unit===this.unit))throw new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);const a={mpp:{amount:e}},i={unit:this._unit,request:t,options:a};return{...await this.mint.createMeltQuote(i),request:t,unit:this._unit}}async checkMeltQuote(t){const e=typeof t=="string"?t:t.quote,s=await this.mint.checkMeltQuote(e);return typeof t=="string"?s:{...s,request:t.request,unit:t.unit}}async meltProofs(t,e,s){const{keysetId:r,counter:o,privkey:a}=s||{},i=await this.getKeys(r),c=this.createBlankOutputs(U(e)-t.amount,i,o,this._keepFactory);a!=null&&(e=ct.getSignedProofs(e.map(f=>({amount:f.amount,C:K.pointFromHex(f.C),id:f.id,secret:new TextEncoder().encode(f.secret)})),a).map(f=>D.serializeProof(f))),e=L(e);const u={quote:t.quote,inputs:e,outputs:c.map(f=>f.blindedMessage)},d=await this.mint.melt(u);return{quote:{...d,unit:t.unit,request:t.request},change:d.change?.map((f,y)=>c[y].toProof(f,i))??[]}}createSwapPayload(t,e,s,r,o,a,i,c,u){const d=e.reduce((p,T)=>p+T.amount,0);r&&r.sendAmounts&&!r.keepAmounts&&(r.keepAmounts=A(d-t-this.getFeesForProofs(e),s.keys));const f=d-t-this.getFeesForProofs(e);let y=[],h=[];if(c?.keep)if(J(c.keep)){const p=c.keep;A(f,s.keys).forEach(B=>{y.push(p(B,s))})}else y=c.keep;else y=this.createOutputData(f,s,o,void 0,r?.keepAmounts,void 0,this._keepFactory);if(c?.send)if(J(c.send)){const p=c.send;A(t,s.keys).forEach(B=>{h.push(p(B,s))})}else h=c.send;else h=this.createOutputData(t,s,o?o+y.length:void 0,a,r?.sendAmounts,u);i&&(e=ct.getSignedProofs(e.map(p=>({amount:p.amount,C:K.pointFromHex(p.C),id:p.id,secret:new TextEncoder().encode(p.secret)})),i).map(p=>D.serializeProof(p))),e=L(e);const l=[...y,...h],w=l.map((p,T)=>T).sort((p,T)=>l[p].blindedMessage.amount-l[T].blindedMessage.amount),m=[...Array(y.length).fill(!0),...Array(h.length).fill(!1)],g=w.map(p=>l[p]),k=w.map(p=>m[p]);return{payload:{inputs:e,outputs:g.map(p=>p.blindedMessage)},outputData:g,keepVector:k,sortedIndices:w}}async checkProofsStates(t){const e=new TextEncoder,s=t.map(a=>K.hashToCurve(e.encode(a.secret)).toHex(!0)),r=100,o=[];for(let a=0;a<s.length;a+=r){const i=s.slice(a,a+r),{states:c}=await this.mint.check({Ys:i}),u={};c.forEach(d=>{u[d.Y]=d});for(let d=0;d<i.length;d++){const f=u[i[d]];if(!f)throw new Error("Could not find state for proof with Y: "+i[d]);o.push(f)}}return o}async onMintQuoteUpdates(t,e,s){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=this.mint.webSocketConnection.createSubscription({kind:"bolt11_mint_quote",filters:t},e,s);return()=>{this.mint.webSocketConnection?.cancelSubscription(r,e)}}async onMeltQuotePaid(t,e,s){return this.onMeltQuoteUpdates([t],r=>{r.state===O.PAID&&e(r)},s)}async onMintQuotePaid(t,e,s){return this.onMintQuoteUpdates([t],r=>{r.state===H.PAID&&e(r)},s)}async onMeltQuoteUpdates(t,e,s){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=this.mint.webSocketConnection.createSubscription({kind:"bolt11_melt_quote",filters:t},e,s);return()=>{this.mint.webSocketConnection?.cancelSubscription(r,e)}}async onProofStateUpdates(t,e,s){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=new TextEncoder,o={};for(let c=0;c<t.length;c++){const u=K.hashToCurve(r.encode(t[c].secret)).toHex(!0);o[u]=t[c]}const a=Object.keys(o),i=this.mint.webSocketConnection.createSubscription({kind:"proof_state",filters:a},c=>{e({...c,proof:o[c.Y]})},s);return()=>{this.mint.webSocketConnection?.cancelSubscription(i,e)}}createOutputData(t,e,s,r,o,a,i){let c;if(r)c=I.createP2PKData({pubkey:r},t,e,o);else if(s||s===0){if(!this._seed)throw new Error("cannot create deterministic messages without seed");c=I.createDeterministicData(t,this._seed,s,e,o)}else a?c=I.createP2PKData(a,t,e,o):i?c=A(t,e.keys).map(d=>i(d,e)):c=I.createRandomData(t,e,o);return c}createBlankOutputs(t,e,s,r){let o=Math.ceil(Math.log2(t))||1;o<0&&(o=0);const a=o?Array(o).fill(1):[];return this.createOutputData(a.length,e,s,void 0,a,void 0,r)}}class N{constructor(t,e){this._mintUrl=t,this._customRequest=e,this._mintUrl=qt(t),this._customRequest=e}get mintUrl(){return this._mintUrl}static async mint(t,e,s,r){const o=r||S,a={"Clear-auth":`${s}`},i=await o({endpoint:_(t,"/v1/auth/blind/mint"),method:"POST",requestBody:e,headers:a});if(!v(i)||!Array.isArray(i?.signatures))throw new Error("bad response");return i}async mint(t,e){return N.mint(this._mintUrl,t,e,this._customRequest)}static async getKeys(t,e,s){const o=await(s||S)({endpoint:e?_(t,"/v1/auth/blind/keys",e):_(t,"/v1/auth/blind/keys")});if(!v(o)||!Array.isArray(o.keysets))throw new Error("bad response");return o}async getKeys(t,e){return await N.getKeys(e||this._mintUrl,t,this._customRequest)}static async getKeySets(t,e){return(e||S)({endpoint:_(t,"/v1/auth/blind/keysets")})}async getKeySets(){return N.getKeySets(this._mintUrl,this._customRequest)}}class vt{constructor(t,e){this._keys=new Map,this._keysets=[],this._unit="auth",this.mint=t;let s=[];e?.keys&&!Array.isArray(e.keys)?s=[e.keys]:e?.keys&&Array.isArray(e?.keys)&&(s=e?.keys),s&&s.forEach(r=>this._keys.set(r.id,r)),e?.keysets&&(this._keysets=e.keysets)}get keys(){return this._keys}get keysetId(){if(!this._keysetId)throw new Error("No keysetId set");return this._keysetId}set keysetId(t){this._keysetId=t}get keysets(){return this._keysets}async loadMint(){await this.getKeySets(),await this.getKeys()}getActiveKeyset(t){let e=t.filter(r=>r.active);e=e.filter(r=>r.id.startsWith("00"));const s=e.sort((r,o)=>(r.input_fee_ppk??0)-(o.input_fee_ppk??0))[0];if(!s)throw new Error("No active keyset found");return s}async getKeySets(){const e=(await this.mint.getKeySets()).keysets.filter(s=>s.unit===this._unit);return this._keysets=e,this._keysets}async getAllKeys(){const t=await this.mint.getKeys();return this._keys=new Map(t.keysets.map(e=>[e.id,e])),this.keysetId=this.getActiveKeyset(this._keysets).id,t.keysets}async getKeys(t,e){if((!(this._keysets.length>0)||e)&&await this.getKeySets(),t||(t=this.getActiveKeyset(this._keysets).id),!this._keysets.find(s=>s.id===t)&&(await this.getKeySets(),!this._keysets.find(s=>s.id===t)))throw new Error(`could not initialize keys. No keyset with id '${t}' found`);if(!this._keys.get(t)){const s=await this.mint.getKeys(t);this._keys.set(t,s.keysets[0])}return this.keysetId=t,this._keys.get(t)}async mintProofs(t,e,s){const r=await this.getKeys(s?.keysetId),o=I.createRandomData(t,r),a={outputs:o.map(u=>u.blindedMessage)},{signatures:i}=await this.mint.mint(a,e),c=o.map((u,d)=>u.toProof(i[d],r));if(c.some(u=>!et(u,r)))throw new Error("Mint returned auth proofs with invalid DLEQ");return c}}function Mt(n){const t={id:n.id,secret:n.secret,C:n.C},e=yt(t);return"auth"+"A"+e}async function Ee(n,t,e){const s=new N(t);return(await new vt(s).mintProofs(n,e)).map(a=>Mt(a))}exports.CashuAuthMint=N;exports.CashuAuthWallet=vt;exports.CashuMint=E;exports.CashuWallet=be;exports.CheckStateEnum=ye;exports.HttpResponseError=F;exports.MeltQuoteState=O;exports.MintOperationError=$;exports.MintQuoteState=H;exports.NetworkError=z;exports.OutputData=I;exports.PaymentRequest=j;exports.PaymentRequestTransportType=Tt;exports.decodePaymentRequest=ie;exports.deriveKeysetId=re;exports.getBlindedAuthToken=Ee;exports.getDecodedToken=At;exports.getDecodedTokenBinary=de;exports.getEncodedAuthToken=Mt;exports.getEncodedToken=se;exports.getEncodedTokenBinary=he;exports.getEncodedTokenV4=Et;exports.hasValidDleq=et;exports.injectWebSocketImpl=le;exports.setGlobalRequestOptions=me;
//# sourceMappingURL=cashu-ts.cjs.js.map
